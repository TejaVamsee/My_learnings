# Memory Errors
- When a program improperly uses the memory causes the memory errors.
- Memory errors are caused by reading or writing to invalid memory locations, forgetting to free memory, or accessing memory after it has been freed.
- These results in undefined behavior, which means the program can crash, produce incorrect results, or appear to work but fail unpredictably later.

# Tools to detect the memory Errors
-  Valgrind - linux,Unix
-  AddressSanitizer - Linux,Windows
-  LeakSanitizer - Linux

# Debbuger
- Gdb (Gnu debugger) - to debug the Segmentation error

## Install the Valgrind Tool
- sudo apt install Valgrind

## 1. Memory Leaks
```c
#include <stdlib.h>
int main() {
    int* ptr = malloc(100); // never freed
    return 0;
}

```
## Output

<img width="947" height="380" alt="image" src="https://github.com/user-attachments/assets/03c9acf9-57a4-498c-8ee0-8a1947234910" /> 

#### This is an example of Definetly lost

### 1.1 Memory leaks

```c
#include <stdlib.h>

struct Student {
    int* data;
};

int main() {
    struct Student* c = malloc(sizeof(struct Student));
    c->data = malloc(100); 

    // No free call
    return 0;
}
```
## Output
<img width="895" height="335" alt="image" src="https://github.com/user-attachments/assets/bbc34902-0b08-44f0-93e1-b6211f293205" />

####  This is an example of Indirectly lost

## 2. Address Memory Leak
```c
#include <stdlib.h>
int* leak() {
    return malloc(100); 
}
int main() {
    leak();
    return 0;
}
```
## Output
<img width="794" height="446" alt="image" src="https://github.com/user-attachments/assets/382d16b4-1691-411f-a00d-18ac3720e276" />

#### This is an example of Definetly lost

## 3. Still Reachable
```c
#include <stdlib.h>
int* global;
int main() {
    global = malloc(50); // not freed
    func();
    return 0;
}
void func()
{
 int *ptr;
 ptr = malloc(100);
}
```
## Output
<img width="794" height="446" alt="image" src="https://github.com/user-attachments/assets/d78aef50-d77f-4536-9ed8-9ba144ccfb42" />

#### This is an example of Definetly lost and Still Reachable

## 4. Accessing the variable after Free/ Invalid Read or Write Error
```c
#include <stdlib.h>
int main() {
    int* p = malloc(4);
    free(p);
    *p = 10; 
    return 0;
}

```
## Output
<img width="969" height="507" alt="image" src="https://github.com/user-attachments/assets/14623903-e581-419e-b193-88ffe3cb5d68" />

#### This is an example of Invalid Write Error

## 5. Buffer Overflow 
```c
#include <stdlib.h>
int main() {
    int* arr = malloc(5 * sizeof(int));
    arr[5] = 42; // writing out-of-bounds
    free(arr);
    return 0;

```
## Output
<img width="955" height="442" alt="image" src="https://github.com/user-attachments/assets/a1a9749d-d5fd-439e-be16-e4dc54d1d7a2" />

## 6. Double Free
```c
#include <stdlib.h>
int main() {
    int* p = malloc(4);
    free(p);
    free(p); // second free is invalid
    return 0;
}

```

## Output
<img width="949" height="401" alt="image" src="https://github.com/user-attachments/assets/2a832d45-6839-450c-bb64-9dea25002172" />

## 7. Improper realloc Handling
```c
#include <stdlib.h>
int main() {
    int* p = malloc(10);
    p = realloc(p, 1000000000); // if fails, original pointer is lost
    p[0] = 1; // invalid if realloc failed
    return 0;
}
```

## Output
<img width="949" height="401" alt="image" src="https://github.com/user-attachments/assets/25582ff6-4ae3-4632-825f-89e22b3b8ec5" />

#### This is an example of Possible lost in Heap

## 8. Uninilized Memory 
```c
#include <stdio.h>
int main() {
    int x;
    printf("%d\n", x); // uninitialized read
    return 0;
}
```

## Output
![Uploading image.pngâ€¦]()
